# import structlog
from serial import Serial, SerialException
from pyvisa.errors import VisaIOError
from PySide2.QtCore import QObject, Signal, Slot
from . import common
from .common import RawData, Preamble
from .oscilloscope import Oscilloscope


# logger = structlog.get_logger()


class ExperimentSignals(QObject):
    """Signals that may be generated by the experiment worker.

    new_data : RawData
        Contains the parallel, perpendicular, reference, and shutter traces
        from the oscilloscope. Generated for each acquisition.
    error : (exctype, value, traceback.format_exc())
        Emitted when there is an error in the experiment.
    """

    new_data = Signal(RawData)
    preamble = Signal(Preamble)
    done = Signal()
    error = Signal(tuple)


class ExperimentWorker(QObject):
    """Worker thread responsible for controlling data acquisition.

    This worker thread communicates with the oscilloscope, setting triggers and
    transfering data when it's ready.

    Notes
    -----
    Currently this only generates dummy data and does not communicate with the
    oscilloscope.
    """

    def __init__(self, mutex, ui_settings):
        super(ExperimentWorker, self).__init__()
        self.mutex = mutex
        self.signals = ExperimentSignals()
        # self._log = logger.bind(worker="experiment")
        # log = self._log.bind(method="__init__")
        self.prev_had_pump = None
        self.start_pt = ui_settings.start_pt
        self.stop_pt = ui_settings.stop_pt
        try:
            self._scope = Oscilloscope(ui_settings.instr_name)
            # log.debug("oscilloscope connected")
            self._shutter = Serial("COM4", baudrate=9_600, timeout=1)
            # log.debug("arduino connected")
        except (VisaIOError, SerialException, ValueError) as e:
            # log.err(e)
            self.mutex.lock()
            # log.debug("mutex locked")
            common.SHOULD_STOP = True
            self.mutex.unlock()
            # log.debug("mutex unlocked")

    def _ensure_basic_settings(self):
        """Ensure that a few settings always have default values.
        """
        self._scope.set_hi_res_mode()
        self._scope.set_continuous_acquisition_mode()
        self._scope.set_waveform_data_source_single_channel(1)
        self._scope.set_waveform_encoding_ascii()
        self._scope.set_waveform_start_point(1)
        self._scope.set_waveform_stop_point(self._scope.get_waveform_length())
        self._scope.add_immediate_mean_measurement(4)
        self._scope.set_waveform_start_point(self.start_pt)
        if self.stop_pt is None:
            self._scope.set_waveform_stop_point(10_000_000)
        else:
            self._scope.set_waveform_stop_point(self.stop_pt)

    def _send_preamble(self):
        """Send the data needed to reconstruct signals from the oscilloscope.
        """
        time_res = self._scope.get_time_resolution()
        self._scope.set_waveform_data_source_single_channel(1)
        v_scale_par = self._scope.get_voltage_scale_factor()
        v_offset_par = self._scope.get_vertical_offset_volts()
        self._scope.set_waveform_data_source_single_channel(2)
        v_scale_perp = self._scope.get_voltage_scale_factor()
        v_offset_perp = self._scope.get_vertical_offset_volts()
        self._scope.set_waveform_data_source_single_channel(3)
        v_scale_ref = self._scope.get_voltage_scale_factor()
        v_offset_ref = self._scope.get_vertical_offset_volts()
        points = self._scope.get_waveform_length()
        data = Preamble(
            time_res,
            v_scale_par,
            v_offset_par,
            v_scale_perp,
            v_offset_perp,
            v_scale_ref,
            v_offset_ref,
            points,
        )
        self.signals.preamble.emit(data)

    @Slot()
    def measure(self):
        """Collect a measurement from the oscilloscope.
        """
        # log = self._log.bind(method="measure")
        self.mutex.lock()
        # log.debug("mutex locked")
        if common.SHOULD_STOP:
            self.mutex.unlock()
            # log.debug("mutex unlocked")
            # log.debug("aborting measurement")
            return
        self.mutex.unlock()
        # log.debug("mutex unlocked")
        self._ensure_basic_settings()
        # log.debug("basic settings set")
        self._send_preamble()
        # log.debug("preamble sent")
        self._scope.acquisition_start()
        # log.debug("oscilloscope started")
        self._shutter.reset_input_buffer()
        # log.debug("arduino buffer cleared")
        while True:
            self.mutex.lock()
            if common.SHOULD_STOP:
                self.mutex.unlock()
                break
            self.mutex.unlock()
            if self._scope.get_trigger_state() == "ready":
                # log.debug("oscilloscope is ready")
                try:
                    state = self._shutter.read(4)
                    # log.debug("shutter", state=state)
                except Exception as e:
                    log.err(e)
                # has_pump = self._scope.get_immediate_measurement_value() > 2.5
                # log.debug("shutter", has_pump=has_pump)
                if state == b"open":
                    has_pump = True
                elif state == b"shut":
                    has_pump = False
                else:
                    continue
                # has_pump = state == "open"
                if self.prev_had_pump is None:
                    # storing the opposite of has_pump prevents skipping the first measurement
                    self.prev_had_pump = not has_pump
                    # log.debug("stored initial pump state", prev_had_pump=(not has_pump))
                if has_pump and self.prev_had_pump:
                    # log.debug("skipping two successive pumps")
                    continue
                elif (not has_pump) and (not self.prev_had_pump):
                    # log.debug("skipping two successive no-pumps")
                    continue
                else:
                    # log.debug("collecting data from oscilloscope")
                    self._scope.set_waveform_data_source_single_channel(1)
                    par = self._scope.get_curve()
                    self._scope.set_waveform_data_source_single_channel(2)
                    perp = self._scope.get_curve()
                    self._scope.set_waveform_data_source_single_channel(3)
                    ref = self._scope.get_curve()
                    data = RawData(par, perp, ref, has_pump)
                    self.signals.new_data.emit(data)
                    # log.debug("new data signal emitted")
                    self.prev_had_pump = has_pump
        self._scope.acquisition_stop()
        # log.debug("oscilloscope stopped")
        self._scope.cleanup()
        # log.debug("oscilloscope disconnected")
        self._shutter.close()
        # log.debug("arduino disconnected")
        self.signals.new_data.disconnect()
        self.signals.done.emit()
        # log.debug("done signal emitted")
