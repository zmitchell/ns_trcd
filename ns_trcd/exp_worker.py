import traceback
import sys
import numpy as np
from pyvisa.errors import VisaIOError
from PySide2.QtCore import QObject, Signal, Slot
from . import common
from .common import RawData, Preamble
from .oscilloscope import Oscilloscope


class ExperimentSignals(QObject):
    """Signals that may be generated by the experiment worker.

    new_data : RawData
        Contains the parallel, perpendicular, reference, and shutter traces
        from the oscilloscope. Generated for each acquisition.
    error : (exctype, value, traceback.format_exc())
        Emitted when there is an error in the experiment.
    """

    new_data = Signal(RawData)
    preamble = Signal(Preamble)
    done = Signal()
    error = Signal(tuple)


class ExperimentWorker(QObject):
    """Worker thread responsible for controlling data acquisition.

    This worker thread communicates with the oscilloscope, setting triggers and
    transfering data when it's ready.

    Notes
    -----
    Currently this only generates dummy data and does not communicate with the
    oscilloscope.
    """

    def __init__(self, mutex, instr_name):
        super(ExperimentWorker, self).__init__()
        self.mutex = mutex
        self.signals = ExperimentSignals()
        self.prev_had_pump = None
        try:
            self._scope = Oscilloscope(instr_name)
        except VisaIOError:
            traceback.print_exc()
            exctype, excvalue = sys.exc_info()[:2]
            self.signals.error.emit((exctype, excvalue, traceback.format_exc()))
            self.mutex.lock()
            common.SHOULD_STOP = True
            self.mutex.unlock()

    def _ensure_basic_settings(self):
        self._scope.set_hi_res_mode()
        self._scope.set_continuous_acquisition_mode()
        self._scope.set_waveform_data_source_single_channel(1)
        self._scope.set_waveform_encoding_ascii()
        self._scope.set_waveform_start_point(1)
        self._scope.set_waveform_stop_point(self._scope.get_waveform_length())
        self._scope.add_immediate_mean_measurement(4)

    def _send_preamble(self):
        time_res = self._scope.get_time_resolution()
        self._scope.set_waveform_data_source_single_channel(1)
        v_scale_par = self._scope.get_voltage_scale_factor()
        v_offset_par = self._scope.get_vertical_offset_volts()
        self._scope.set_waveform_data_source_single_channel(2)
        v_scale_perp = self._scope.get_voltage_scale_factor()
        v_offset_perp = self._scope.get_vertical_offset_volts()
        self._scope.set_waveform_data_source_single_channel(3)
        v_scale_ref = self._scope.get_voltage_scale_factor()
        v_offset_ref = self._scope.get_vertical_offset_volts()
        self._scope.set_waveform_data_source_single_channel(4)
        v_scale_shutter = self._scope.get_voltage_scale_factor()
        v_offset_shutter = self._scope.get_vertical_offset_volts()
        points = self._scope.get_waveform_length()
        data = Preamble(time_res, v_scale_par, v_offset_par, v_scale_perp, v_offset_perp, v_scale_ref, v_offset_ref, v_scale_shutter, v_offset_shutter, points)
        self.signals.preamble.emit(data)

    @Slot()
    def measure(self):
        self.mutex.lock()
        if common.SHOULD_STOP:
            return
        self.mutex.unlock()
        self._ensure_basic_settings()
        self._send_preamble()
        self._scope.acquisition_start()
        while True:
            self.mutex.lock()
            if common.SHOULD_STOP:
                self.mutex.unlock()
                break
            self.mutex.unlock()
            if self._scope.get_trigger_state() == "ready":
                has_pump = self._scope.get_immediate_measurement_value() > 2.5
                if self.prev_had_pump is None:
                    self.prev_had_pump = not has_pump
                if has_pump and self.prev_had_pump:
                    continue
                elif (not has_pump) and (not self.prev_had_pump):
                    continue
                else:
                    self._scope.set_waveform_data_source_single_channel(1)
                    par = self._scope.get_curve()
                    self._scope.set_waveform_data_source_single_channel(2)
                    perp = self._scope.get_curve()
                    self._scope.set_waveform_data_source_single_channel(3)
                    ref = self._scope.get_curve()
                    self._scope.set_waveform_data_source_single_channel(4)
                    shutter = self._scope.get_curve()
                    data = RawData(par, perp, ref, shutter)
                    self.signals.new_data.emit(data)
                    self.prev_had_pump = has_pump
        self._scope.acquisition_stop()
        self._scope.cleanup()
        self.signals.new_data.disconnect()
        self.signals.done.emit()
