import numpy as np
from dataclasses import dataclass
from PySide2.QtWidgets import QMainWindow
from PySide2.QtCore import QThread, QObject, Signal, Slot, QTimer
from .generated_ui import Ui_MainWindow


POINTS = 1_000


@dataclass
class PlotData:
    """Raw and processed data to be displayed in the UI.

    Notes
    -----
    The data in the da_* and avg_da_* fields are not always new since it takes
    two acquisitions to calculate those signals.
    """

    time: np.ndarray
    par: np.ndarray
    perp: np.ndarray
    ref: np.ndarray
    da_par: np.ndarray
    da_perp: np.ndarray
    da_cd: np.ndarray
    avg_da_par: np.ndarray
    avg_da_perp: np.ndarray
    avg_da_cd: np.ndarray
    new_da: bool


@dataclass
class RawData:
    """Data from a single oscilloscope acquisition.
    """

    par: np.ndarray
    perp: np.ndarray
    ref: np.ndarray
    shutter: np.ndarray


class ComputationSignals(QObject):
    """Signals produced by the computation worker

    data : PlotData
        Emitted when new data is ready.
    """

    new_data = Signal(PlotData)


class ComputationWorker(QObject):
    """Worker thread responsible for computing and storing experiment data.

    This worker receives the raw data from the perpendicular, parallel, and reference
    channels, then performs the dA and CD calculations on that data. The data is then
    stored and passed on to be displayed in the GUI.

    Notes
    -----
    Currently only performs dummy calculations with dummy data sent from the experiment
    worker.
    """

    def __init__(self):
        super(ComputationWorker, self).__init__()
        self.signals = ComputationSignals()
        self.exiting = False
        self.count = 0
        self.avg_da_par = np.zeros(POINTS)
        self.avg_da_perp = np.zeros(POINTS)
        self.avg_da_cd = np.zeros(POINTS)

    @Slot(RawData)
    def compute_signals(self, data):
        """Compute dA from the oscilloscope traces.

        Parameters
        ----------
        data : RawData
            The parallel, perpendicular, reference, and shutter traces from
            the oscilloscope.

        Emits
        -----
        PlotData

        Notes
        -----
        New dA traces are only generated on every other acquisition since you
        need measurements with and without the pump in order to calculate dA.
        """

        time = np.arange(POINTS)
        da_par = data.par + data.ref
        da_perp = data.perp + data.ref
        da_cd = data.par + data.perp
        self.count += 1
        if (self.count >= 2) and (self.count % 2 == 0):
            if self.count == 2:  # the first round, nothing to average yet
                self.avg_da_par = da_par
                self.avg_da_perp = da_perp
                self.avg_da_cd = da_cd
            else:
                self.avg_da_par = (self.count - 1) / self.count * self.avg_da_par + (
                    1 / self.count
                ) * da_par
                self.avg_da_perp = (self.count - 1) / self.count * self.avg_da_perp + (
                    1 / self.count
                ) * da_perp
                self.avg_da_cd = (self.count - 1) / self.count * self.avg_da_cd + (
                    1 / self.count
                ) * da_cd
        data = PlotData(
            time,
            data.par,
            data.perp,
            data.ref,
            da_par,
            da_perp,
            da_cd,
            self.avg_da_par,
            self.avg_da_perp,
            self.avg_da_cd,
            self.count % 2 == 0,
        )
        self.signals.new_data.emit(data)


class ExperimentSignals(QObject):
    """Signals that may be generated by the experiment worker.

    new_data : RawData
        Contains the parallel, perpendicular, reference, and shutter traces
        from the oscilloscope. Generated for each acquisition.
    """
    new_data = Signal(RawData)


class ExperimentWorker(QObject):
    """Worker thread responsible for controlling data acquisition.

    This worker thread communicates with the oscilloscope, setting triggers and
    transfering data when it's ready.

    Notes
    -----
    Currently this only generates dummy data and does not communicate with the
    oscilloscope.
    """

    def __init__(self):
        super(ExperimentWorker, self).__init__()
        self.signals = ExperimentSignals()
        self.rng = np.random.default_rng()
        self.timer = QTimer()
        self.timer.setInterval(100)  # in ms
        self.timer.timeout.connect(self.generate)
        self.timer.start()

    @Slot()
    def generate(self):
        """A temporary method that generates dummy data on each iteration of the timer.
        """
        par = self.rng.random(POINTS)
        perp = self.rng.random(POINTS)
        ref = self.rng.random(POINTS)
        shutter = self.rng.random(POINTS)
        data = RawData(par, perp, ref, shutter)
        self.signals.new_data.emit(data)

    def finish(self):
        """A temporary method to stop the timer.
        """
        self.timer.stop()


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.ui.start_btn.clicked.connect(self.start_collection)
        self.ui.stop_btn.clicked.connect(self.stop_collection)
        self.collecting = False
        self.comp_thread = QThread()
        self.exp_thread = QThread()
        self._store_line_objects()

    def _store_line_objects(self):
        """Store references to the lines so the data can be updated later.
        """
        starting_data = (np.arange(100), np.zeros(100))
        self.live_par_line = self.ui.live_par_graph.plot(*starting_data)
        self.live_perp_line = self.ui.live_perp_graph.plot(*starting_data)
        self.live_ref_line = self.ui.live_ref_graph.plot(*starting_data)
        self.live_da_par_line = self.ui.live_da_par_graph.plot(*starting_data)
        self.live_da_perp_line = self.ui.live_da_perp_graph.plot(*starting_data)
        self.live_da_cd_line = self.ui.live_da_cd_graph.plot(*starting_data)
        self.avg_da_par_line = self.ui.avg_da_par_graph.plot(*starting_data)
        self.avg_da_perp_line = self.ui.avg_da_perp_graph.plot(*starting_data)
        self.avg_da_cd_line = self.ui.avg_da_cd_graph.plot(*starting_data)

    @Slot()
    def start_collection(self):
        """Begins generating data when the "Start" button is pressed.
        """
        if self.collecting:
            return
        self.comp_worker = ComputationWorker()
        self.exp_worker = ExperimentWorker()
        self.comp_worker.signals.new_data.connect(self.update_plots)
        self.exp_worker.signals.new_data.connect(self.comp_worker.compute_signals)
        self.comp_worker.moveToThread(self.comp_thread)
        self.exp_worker.moveToThread(self.exp_thread)
        self.comp_thread.start()
        self.exp_thread.start()
        self.collecting = True

    @Slot()
    def stop_collection(self):
        """Stops generating data when the "Stop" button is pressed.
        """
        if not self.collecting:
            return
        self.exp_worker.finish()
        self.exp_worker.signals.new_data.disconnect(self.comp_worker.compute_signals)
        self.comp_thread.quit()
        self.exp_thread.quit()
        self.comp_thread.wait()
        self.exp_thread.wait()
        self.collecting = False

    @Slot(PlotData)
    def update_plots(self, data):
        """Update the plots in the "Live" tab when new data is available.

        Parameters
        ----------
        data : PlotData
            Three live data channels and the signals computed from them.
        """
        self.live_par_line.setData(data.time, data.par)
        self.live_perp_line.setData(data.time, data.perp)
        self.live_ref_line.setData(data.time, data.ref)
        if data.new_da:
            self.live_da_par_line.setData(data.time, data.da_par)
            self.live_da_perp_line.setData(data.time, data.da_perp)
            self.live_da_cd_line.setData(data.time, data.da_cd)
            self.avg_da_par_line.setData(data.time, data.avg_da_par)
            self.avg_da_perp_line.setData(data.time, data.avg_da_perp)
            self.avg_da_cd_line.setData(data.time, data.avg_da_cd)
